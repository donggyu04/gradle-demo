buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath group: 'commons-codec', name: 'commons-codec', version: '1.2'
        classpath group: 'javax.inject', name: 'javax.inject', version: '1'
    }
}

plugins {
    id 'org.springframework.boot' version '2.2.6.RELEASE'
    id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    id 'java'
    id 'base' // for zip task
}


group = 'com.training'
version = '0.0.1'

sourceCompatibility = '1.8'
targetCompatibility = '1.8'

repositories {
    mavenCentral()
}

project.archivesBaseName = 'replaced-jar-name'
project.version = '1.0.0'

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }

    compile group: 'joda-time', name: 'joda-time', version: '2.10.5'
}

defaultTasks 'aaa', 'bbb'

task copy(type: Copy, group: 'Custom', description: 'Copies sources to the dest directory') {
    from 'src'
    into 'dest'
}

task zip(type: Zip, group: 'Archive', description: 'Archives sources in a zip file') {
    doFirst {
        println('*** start:zip task ***')
    }
    String zipFileName = 'basic-demo-1.0.zip'
    from 'src'
    getArchiveFileName().convention(zipFileName)
    getArchiveFileName().set(zipFileName)
}

// dependsOn test
task aaa {
    String message = 'This is aaa task'
    doLast {
        println("*** $message $hello.testProperty***")
        println("*** ${message.toUpperCase()} ***")
    }
}

task hello(dependsOn:['aaa', 'bbb']) {
    doFirst {
        println('*** start:hello task ***')
    }

    doLast {
        println('*** end:hello task ***')
    }

    ext.testProperty = 'Extra test property'
}
// hello.dependsOn aaa, bbb

task bbb {
    doLast {
        println("*** I'm task bbb ***")
    }
}

bbb.doLast {
    println("*** Appended message ***")
}

//

task loadStaticFiles {
    doLast {
        fileList('./src/main/resources/static').each { File file ->
            if (file.isFile()) {
                ant.loadfile(srcFile: file, property: file.name)
                println " *** $file.name ***"
                println "${ant.properties[file.name]}"
            }
        }
    }
}

File[] fileList(String dir) {
    return file(dir).listFiles({file -> file.isFile()} as FileFilter).sort()
}

task count {
    doLast {
        4.times {
            print "$it "
        }
    }
}

task distribution {
    doLast {
        println "We build the zip with version=$version"
    }
}

task release {
    dependsOn 'distribution'
    doLast {
        println 'We release now'
    }
}

gradle.taskGraph.whenReady { taskGraph ->
    if (taskGraph.hasTask(":release")) {
        version = '1.0'
    } else {
        version = '1.0-SNAPSHOT'
    }
}

import org.apache.commons.codec.binary.Base64
task encode {
    doLast {
        def encodedString = new Base64().encode('hello world\n'.getBytes())
        println new String(encodedString)
    }
}

test {
    useJUnitPlatform()
}

build.dependsOn zip

//

task showTaskInfo {
    doLast {
        println 'showTaskInfo was called'
    }
}

//tasks.getByPath(':showTaskInfo')

// Using a Groovy Closure
showTaskInfo.dependsOn {
    tasks.findAll { task -> task.name.startsWith('custom') }
}

import javax.inject.Inject
class CustomTask extends DefaultTask {
    final String message
    final int number

    @Inject
    CustomTask(String message, int number) {
        this.message = message
        this.number = number
    }
}

task customTask(type: CustomTask, constructorArgs: ['hello', 42]) {
    doLast {
        println "$message $number"
    }
}

task taskX {
    doLast {
        println 'taskX'
    }
}

import java.time.Duration
task taskY {
    timeout = Duration.ofSeconds(2)
    doFirst {
        println 'taskY before exception'
        Thread.sleep(3000)
        throw new StopExecutionException()
    }

    doLast {
        println 'taskY'
    }
}

//taskY.enabled = false
//taskX.dependsOn taskY
//taskY.mustRunAfter taskX // Error occurred with circular dependency
//taskY.shouldRunAfter taskX
taskY.finalizedBy taskX


